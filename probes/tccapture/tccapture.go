package tccapture

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"math"
	"net"
	"strings"

	"github.com/JamesYYang/jebpf/probes"
	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/vishvananda/netlink"
	"golang.org/x/sys/unix"
)

var tcType = make(map[int]string)

type TcCapture_Probe struct {
	name           string
	bpf            *tccaptureObjects
	ingressFileter *netlink.BpfFilter
	egressFileter  *netlink.BpfFilter
	reader         *ringbuf.Reader
}

func init() {
	h := &TcCapture_Probe{}
	h.name = "tccapture_bpf"
	tcType[1] = "INGRESS"
	tcType[0] = "EGRESS"
	probes.RegisterProbe(h)
}

func (p *TcCapture_Probe) Name() string {
	return p.name
}

// Cilium Attach TC
// https://github.com/cilium/cilium/blob/master/pkg/datapath/loader/netlink.go#L165

//show filter
//tc filter show dev eth0 ingress(egress)
//customize deleteed TC filter
//tc filter del dev eth0 ingress(egress)

func (p *TcCapture_Probe) Start() {

	objs := tccaptureObjects{}

	if err := loadTccaptureObjects(&objs, &ebpf.CollectionOptions{
		Programs: ebpf.ProgramOptions{
			LogLevel: ebpf.LogLevelInstruction,
			LogSize:  math.MaxUint32 >> 2,
		},
	}); err != nil {
		log.Fatalf("loading objects: %v", err)
	}
	p.bpf = &objs

	_, ifIndex, _ := probes.GetLocalIP()

	link, err := netlink.LinkByIndex(ifIndex)
	if err != nil {
		log.Fatalf("create net link failed: %v", err)
	}

	sec := "classifier/ingress"
	inf, err := p.attachTC(link, objs.IngressClsFunc, sec, netlink.HANDLE_MIN_INGRESS)
	if err != nil {
		log.Fatalf("attach tc ingress failed, %v", err)
	}
	p.ingressFileter = inf

	sec = "classifier/egress"
	ef, err := p.attachTC(link, objs.EgressClsFunc, sec, netlink.HANDLE_MIN_EGRESS)
	if err != nil {
		log.Fatalf("attach tc egress failed, %v", err)
	}
	p.egressFileter = ef

	rd, err := ringbuf.NewReader(objs.TcCaptureEvents)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	p.reader = rd

	log.Println("Waiting for events..")
	log.Printf("%-10s %-10s %-10s %-16s %-10s %-10s %-16s %-6s -> %-16s %-6s",
		"Ifindex",
		"Protocol",
		"Mark",
		"Flag",
		"Len",
		"Direction",
		"Src addr",
		"Port",
		"Dest addr",
		"Port",
	)

	go func() {
		// bpfEvent is generated by bpf2go.
		var event tccaptureNetPacketEvent
		for {
			record, err := rd.Read()
			if err != nil {
				if errors.Is(err, ringbuf.ErrClosed) {
					log.Println("Received signal, exiting..")
					return
				}
				log.Printf("reading from reader: %s", err)
				continue
			}

			// Parse the ringbuf event entry into a bpfEvent structure.
			if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
				log.Printf("parsing ringbuf event: %s", err)
				continue
			}

			log.Printf("%-10d %-10d %-10d %-16s %-10d %-10s %-16s %-6d -> %-16s %-6d",
				event.Ifindex,
				event.Protocol,
				event.Mark,
				getFlagString(event),
				event.Len,
				tcType[int(event.Ingress)],
				intToIP(event.Sip),
				event.Sport,
				intToIP(event.Dip),
				event.Dport)
		}
	}()

}

func replaceQdisc(link netlink.Link) error {
	attrs := netlink.QdiscAttrs{
		LinkIndex: link.Attrs().Index,
		Handle:    netlink.MakeHandle(0xffff, 0),
		Parent:    netlink.HANDLE_CLSACT,
	}

	qdisc := &netlink.GenericQdisc{
		QdiscAttrs: attrs,
		QdiscType:  "clsact",
	}

	return netlink.QdiscReplace(qdisc)
}

func (p *TcCapture_Probe) attachTC(link netlink.Link, prog *ebpf.Program, progName string, qdiscParent uint32) (*netlink.BpfFilter, error) {
	if err := replaceQdisc(link); err != nil {
		return nil, fmt.Errorf("replacing clsact qdisc for interface %s: %w", link.Attrs().Name, err)
	}

	filter := &netlink.BpfFilter{
		FilterAttrs: netlink.FilterAttrs{
			LinkIndex: link.Attrs().Index,
			Parent:    qdiscParent,
			Handle:    1,
			Protocol:  unix.ETH_P_ALL,
			Priority:  1,
		},
		Fd:           prog.FD(),
		Name:         fmt.Sprintf("%s-%s", progName, link.Attrs().Name),
		DirectAction: true,
	}

	if err := netlink.FilterReplace(filter); err != nil {
		return nil, fmt.Errorf("replacing tc filter: %w", err)
	}

	return filter, nil
}

func (p *TcCapture_Probe) Stop() {
	p.bpf.Close()
	p.reader.Close()
	netlink.FilterDel(p.ingressFileter)
	netlink.FilterDel(p.egressFileter)
}

// intToIP converts IPv4 number to net.IP
func intToIP(ipNum uint32) net.IP {
	ip := make(net.IP, 4)
	binary.LittleEndian.PutUint32(ip, ipNum)
	return ip
}

func getFlagString(event tccaptureNetPacketEvent) string {
	fStr := ""
	if event.Fin == 1 {
		fStr += "fin|"
	}
	if event.Ack == 1 {
		fStr += "ack|"
	}
	if event.Rst == 1 {
		fStr += "rst|"
	}
	if event.Psh == 1 {
		fStr += "psh|"
	}
	if event.Syn == 1 {
		fStr += "syn|"
	}

	if strings.HasSuffix(fStr, "|") {
		return fStr[:strings.LastIndex(fStr, "|")]
	}
	return fStr
}
