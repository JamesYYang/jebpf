package tccapture

import (
	"bytes"
	"encoding/binary"
	"errors"
	"log"
	"net"

	"github.com/JamesYYang/jebpf/probes"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/florianl/go-tc"
	"github.com/florianl/go-tc/core"
	"golang.org/x/sys/unix"
)

var tcType = make(map[int]string)

type TrafficType uint32

const (
	Ingress = TrafficType(tc.HandleMinIngress)
	Egress  = TrafficType(tc.HandleMinEgress)
)

type TcCapture_Probe struct {
	name    string
	bpf     *tccaptureObjects
	netLink *tc.Tc
	tcObj   *tc.Object
	reader  *ringbuf.Reader
}

func init() {
	h := &TcCapture_Probe{}
	h.name = "tccapture_bpf"
	tcType[1] = "INGRESS"
	tcType[0] = "EGRESS"
	probes.RegisterProbe(h)
}

func (p *TcCapture_Probe) Name() string {
	return p.name
}

func (p *TcCapture_Probe) Start() {

	objs := tccaptureObjects{}
	if err := loadTccaptureObjects(&objs, nil); err != nil {
		log.Fatalf("loading objects: %v", err)
	}
	p.bpf = &objs

	_, ifIndex := probes.GetLocalIP()

	netLink, err := tc.Open(&tc.Config{})
	if err != nil {
		log.Fatalf("opening tc failed: %s", err)
	}

	// Create a Qdisc for the provided interface
	qdisc := &tc.Object{
		Msg: tc.Msg{
			Family:  unix.AF_UNSPEC,
			Ifindex: uint32(ifIndex),
			Handle:  core.BuildHandle(tc.HandleRoot, 0x0000),
			Parent:  tc.HandleIngress,
			Info:    0,
		},
		Attribute: tc.Attribute{
			Kind: "clsact",
		},
	}

	// Add the Qdisc
	err = netLink.Qdisc().Add(qdisc)
	if err != nil {
		if err.Error() != "netlink receive: file exists" {
			log.Fatalf("add qdisc failed: %s", err)
		}
	}

	sec := "classifier/ingress"

	// Create qdisc filter
	fd := uint32(objs.tccapturePrograms.IngressClsFunc.FD())
	flag := uint32(1)
	filter := tc.Object{
		Msg: tc.Msg{
			Family:  unix.AF_UNSPEC,
			Ifindex: uint32(ifIndex),
			Handle:  0,
			Parent:  core.BuildHandle(tc.HandleRoot, uint32(Ingress)),
			Info:    0x300,
		},
		Attribute: tc.Attribute{
			Kind: "bpf",
			BPF: &tc.Bpf{
				FD:    &fd,
				Name:  &sec,
				Flags: &flag,
			},
		},
	}

	// Add qdisc filter
	err = netLink.Filter().Add(&filter)
	if err != nil {
		log.Fatalf("add filter to net interface failed: %s", err)

	}

	p.netLink = netLink
	p.tcObj = qdisc

	rd, err := ringbuf.NewReader(objs.TcCaptureEvents)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	p.reader = rd

	log.Println("Waiting for events..")
	log.Printf("%-16s %-16s %-16s %-6s -> %-16s %-6s",
		"TS",
		"Event",
		"Src addr",
		"Port",
		"Dest addr",
		"Port",
	)

	go func() {
		// bpfEvent is generated by bpf2go.
		var event tccaptureNetPacketEvent
		for {
			record, err := rd.Read()
			if err != nil {
				if errors.Is(err, ringbuf.ErrClosed) {
					log.Println("Received signal, exiting..")
					return
				}
				log.Printf("reading from reader: %s", err)
				continue
			}

			// Parse the ringbuf event entry into a bpfEvent structure.
			if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
				log.Printf("parsing ringbuf event: %s", err)
				continue
			}

			log.Printf("%-16d %-16s %-16s %-6d -> %-16s %-6d",
				event.Ts,
				tcType[int(event.Ingress)],
				intToIP(event.Sip),
				event.Sport,
				intToIP(event.Dip),
				event.Dport)
		}
	}()

}

func (p *TcCapture_Probe) Stop() {
	p.bpf.Close()
	p.netLink.Qdisc().Delete(p.tcObj)
	p.reader.Close()
}

// intToIP converts IPv4 number to net.IP
func intToIP(ipNum uint32) net.IP {
	ip := make(net.IP, 4)
	binary.LittleEndian.PutUint32(ip, ipNum)
	return ip
}
